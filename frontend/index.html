<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RscoutX - VEX Pushback æ™ºèƒ½ä¾¦å¯Ÿç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        :root {
            --primary: #667eea;
            --primary-dark: #5568d3;
            --secondary: #764ba2;
            --success: #48bb78;
            --danger: #f56565;
            --warning: #ed8936;
            --info: #4299e1;
            --bg-dark: #1a1a1a;
            --bg-light: #f7fafc;
            --border: #e2e8f0;
            --text-dark: #2d3748;
            --text-light: #718096;
        }
        
        body {
            font-family: 'Segoe UI', 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        /* Header */
        .header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        /* Main Content */
        .main-content {
            padding: 30px;
        }
        
        /* Section */
        .section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid var(--border);
        }
        
        .section-title {
            font-size: 1.5em;
            color: var(--primary);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        /* Search Bar */
        .search-container {
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }
        
        .form-group {
            flex: 1;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: var(--text-dark);
            font-weight: 600;
        }
        
        .form-group input,
        .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-size: 1em;
            transition: all 0.3s;
        }
        
        .form-group input:focus,
        .form-group select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: var(--primary);
            color: white;
        }
        
        .btn-primary:hover {
            background: var(--primary-dark);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn-success {
            background: var(--success);
            color: white;
        }
        
        .btn-success:hover {
            background: #38a169;
            transform: translateY(-2px);
        }
        
        .btn-danger {
            background: var(--danger);
            color: white;
        }
        
        .btn-danger:hover {
            background: #e53e3e;
        }
        
        /* Team Info Card */
        .team-info-card {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .info-item {
            background: var(--bg-light);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
        }
        
        .info-label {
            color: var(--text-light);
            font-size: 0.9em;
            margin-bottom: 8px;
        }
        
        .info-value {
            color: var(--text-dark);
            font-size: 1.8em;
            font-weight: bold;
        }
        
        .info-value.highlight {
            color: var(--primary);
        }
        
        /* Auton Editor */
        .auton-controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .auton-nav {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .auton-counter {
            font-size: 1.2em;
            font-weight: bold;
            color: var(--primary);
            padding: 8px 16px;
            background: var(--bg-light);
            border-radius: 8px;
        }
        
        .canvas-container {
            position: relative;
            border: 3px solid var(--primary);
            border-radius: 12px;
            overflow: hidden;
            background: var(--bg-dark);
            max-width: 100%;
            margin: 0 auto;
        }
        
        #mapCanvas {
            display: block;
            cursor: crosshair;
            max-width: 100%;
            height: auto;
        }
        
        .canvas-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
        }
        
        /* State Selector */
        .state-selector {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .state-btn {
            padding: 12px;
            border: 2px solid var(--border);
            background: white;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-weight: 600;
        }
        
        .state-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .state-btn.active {
            border-color: var(--primary);
            background: var(--primary);
            color: white;
        }
        
        .state-btn.state-idle { border-color: #808080; }
        .state-btn.state-idle.active { background: #808080; border-color: #808080; }
        
        .state-btn.state-moving { border-color: #1E90FF; }
        .state-btn.state-moving.active { background: #1E90FF; border-color: #1E90FF; }
        
        .state-btn.state-intaking { border-color: #00FF00; }
        .state-btn.state-intaking.active { background: #00FF00; border-color: #00FF00; color: #000; }
        
        .state-btn.state-wingpushing { border-color: #FF4500; }
        .state-btn.state-wingpushing.active { background: #FF4500; border-color: #FF4500; }
        
        .state-btn.state-releasing { border-color: #FFD700; }
        .state-btn.state-releasing.active { background: #FFD700; border-color: #FFD700; color: #000; }
        
        /* Points List */
        .points-list {
            max-height: 300px;
            overflow-y: auto;
            background: var(--bg-light);
            border-radius: 10px;
            padding: 15px;
        }
        
        .point-item {
            background: white;
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .point-item .delete-btn {
            background: var(--danger);
            color: white;
            border: none;
            padding: 5px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        /* Robot Type Selector */
        .robot-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        
        .robot-type-card {
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .robot-type-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
        }
        
        .robot-type-card.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
        }
        
        .robot-type-name {
            font-weight: 600;
            color: var(--text-dark);
            font-size: 1.2em;
        }
        
        /* Driver Notes */
        .driver-notes {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: 8px;
            font-family: inherit;
            font-size: 1em;
            resize: vertical;
        }
        
        .driver-notes:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        /* Driver Tags */
        .driver-tag {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 6px 12px;
            background: #f0f0f0;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            user-select: none;
        }
        
        .driver-tag:hover {
            background: #e8e8e8;
            border-color: #ccc;
        }
        
        .driver-tag.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }
        
        .driver-tag.active:hover {
            background: #5a74d4;
            border-color: #5a74d4;
        }
        
        .tag-text {
            pointer-events: none;
        }
        
        .tag-remove {
            margin-left: 5px;
            font-size: 1.2em;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            line-height: 1;
        }
        
        .driver-tag.active .tag-remove {
            color: white;
        }
        
        .tag-remove:hover {
            color: #ff4444;
        }
        
        /* AI Export */
        .ai-export-section {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            padding: 25px;
            border-radius: 15px;
            border: 2px solid var(--primary);
        }
        
        .ai-preview {
            background: white;
            padding: 20px;
            border-radius: 10px;
            margin-top: 15px;
            max-height: 400px;
            overflow-y: auto;
        }
        
        .ai-preview h4 {
            color: var(--primary);
            margin-bottom: 10px;
        }
        
        .ai-preview pre {
            background: var(--bg-dark);
            color: #0f0;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            font-size: 0.9em;
        }
        
        /* Message Toast */
        .message-toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 25px;
            border-radius: 10px;
            color: white;
            font-weight: 600;
            z-index: 10000;
            animation: slideIn 0.3s ease-out;
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        .message-toast.success { background: var(--success); }
        .message-toast.error { background: var(--danger); }
        .message-toast.info { background: var(--info); }
        .message-toast.warning { background: var(--warning); }
        
        /* Loading Spinner */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Responsive */
        @media (max-width: 768px) {
            .search-container {
                flex-direction: column;
            }
            
            .auton-controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>ğŸ¤– RscoutX</h1>
            <p>VEX Pushback æ™ºèƒ½ä¾¦å¯Ÿä¸åˆ†æç³»ç»Ÿ</p>
        </div>

        <div class="main-content">
            <!-- 1. Team Search -->
            <div class="section">
                <div class="section-title">
                    ğŸ” é˜Ÿä¼æœç´¢
                </div>
                <div class="search-container">
                    <div class="form-group" style="flex: 2;">
                        <label>é˜Ÿä¼ç¼–å· Team Number</label>
                        <input type="text" id="teamNumber" placeholder="ä¾‹å¦‚: 1234A, 5678B, 9999C" onkeypress="if(event.key==='Enter') searchTeam()">
                    </div>
                    <button class="btn btn-primary" onclick="searchTeam()">
                        <span>ğŸ” æœç´¢å†å²æ•°æ®</span>
                    </button>
                </div>
                <div style="margin-top: 10px; color: var(--text-light); font-size: 0.9em;">
                    ï¿½ å°†è‡ªåŠ¨åŠ è½½è¯¥é˜Ÿä¼åœ¨æ‰€æœ‰èµ›äº‹ä¸­çš„å†å²æ•°æ®å’Œç»Ÿè®¡ä¿¡æ¯
                </div>
            </div>

            <!-- 2. Team Info & Scores -->
            <div class="section" id="teamInfoSection" style="display: none;">
                <div class="section-title">
                    ğŸ“Š é˜Ÿä¼å†å²ä¿¡æ¯ä¸æ•°æ®ç»Ÿè®¡
                </div>
                <div class="team-info-card">
                    <div class="info-item">
                        <div class="info-label">é˜Ÿä¼ç¼–å·</div>
                        <div class="info-value highlight" id="displayTeamNumber">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">é˜Ÿä¼åç§°</div>
                        <div class="info-value" id="displayTeamName">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æ‰€å±ç»„ç»‡</div>
                        <div class="info-value" id="displayOrganization">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">åœ°åŒº</div>
                        <div class="info-value" id="displayRegion">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">å‚èµ›æ¬¡æ•°</div>
                        <div class="info-value highlight" id="eventCount">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æ€»æ¯”èµ›æ•°</div>
                        <div class="info-value" id="totalMatches">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">å†å²èƒœç‡</div>
                        <div class="info-value highlight" id="winRate">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">å¹³å‡å¾—åˆ†</div>
                        <div class="info-value highlight" id="avgScore">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">æœ€é«˜å¾—åˆ†</div>
                        <div class="info-value" id="maxScore">-</div>
                    </div>
                    <div class="info-item">
                        <div class="info-label">Auton ä¼°ç®—åˆ†</div>
                        <div class="info-value highlight" id="autonScore">-</div>
                    </div>
                </div>
                
                <!-- Recent Matches History -->
                <div style="margin-top: 30px;">
                    <h3 style="color: var(--primary); margin-bottom: 15px;">ğŸ“… è¿‘æœŸæ¯”èµ›è®°å½•</h3>
                    <div id="matchHistory" style="max-height: 400px; overflow-y: auto;"></div>
                </div>
            </div>

            <!-- 3. Auton Path Drawing -->
            <div class="section" id="autonSection" style="display: none;">
                <div class="section-title">
                    ğŸ—ºï¸ Auton è·¯å¾„ç»˜åˆ¶
                </div>
                
                <div class="auton-controls">
                    <div class="auton-nav">
                        <button class="btn btn-primary" onclick="prevAuton()">â¬…ï¸ ä¸Šä¸€ä¸ª</button>
                        <div class="auton-counter">
                            Auton <span id="currentAutonIndex">1</span> / <span id="totalAutons">5</span>
                        </div>
                        <button class="btn btn-primary" onclick="nextAuton()">â¡ï¸ ä¸‹ä¸€ä¸ª</button>
                    </div>
                    <button class="btn btn-success" onclick="addAuton()">â• æ–°å¢ Auton</button>
                    <button class="btn btn-danger" onclick="deleteAuton()">ğŸ—‘ï¸ åˆ é™¤å½“å‰</button>
                    <button class="btn btn-primary" onclick="clearCurrentPath()">ğŸ§¹ æ¸…ç©ºè·¯å¾„</button>
                </div>

                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: 600;">é€‰æ‹©æœºå™¨äººçŠ¶æ€:</label>
                    <div class="state-selector">
                        <div class="state-btn state-idle" data-state="idle" onclick="selectState('idle')">
                            â­• Idle
                        </div>
                        <div class="state-btn state-moving" data-state="moving" onclick="selectState('moving')">
                            ğŸ”µ Moving
                        </div>
                        <div class="state-btn state-intaking" data-state="intaking" onclick="selectState('intaking')">
                            ğŸŸ¢ Intaking
                        </div>
                        <div class="state-btn state-wingpushing active" data-state="wingpushing" onclick="selectState('wingpushing')">
                            ğŸŸ  Wing Push
                        </div>
                        <div class="state-btn state-releasing" data-state="releasing" onclick="selectState('releasing')">
                            ğŸŸ¡ Releasing
                        </div>
                    </div>
                </div>

                <div class="canvas-container">
                    <canvas id="mapCanvas" width="800" height="800"></canvas>
                    <div class="canvas-overlay">
                        ğŸ’¡ ç‚¹å‡»åœ°å›¾æ·»åŠ è·¯å¾„ç‚¹ | æŒ‰ä½æ‹–åŠ¨ç»˜åˆ¶è¿ç»­è·¯å¾„
                    </div>
                </div>

                <div style="margin-top: 20px;">
                    <h3 style="margin-bottom: 10px;">è·¯å¾„ç‚¹åˆ—è¡¨:</h3>
                    <div class="points-list" id="pointsList"></div>
                </div>
            </div>

            <!-- 4. Robot Type -->
            <div class="section" id="robotSection" style="display: none;">
                <div class="section-title">
                    ğŸ¤– æœºå™¨äººç±»å‹
                </div>
                <div class="robot-type-grid">
                    <div class="robot-type-card" data-type="sbot" onclick="selectRobotType('sbot')">
                        <div class="robot-type-name">S-Bot</div>
                    </div>
                    <div class="robot-type-card" data-type="cbot" onclick="selectRobotType('cbot')">
                        <div class="robot-type-name">C-Bot</div>
                    </div>
                    <div class="robot-type-card" data-type="ruiguan" onclick="selectRobotType('ruiguan')">
                        <div class="robot-type-name">ç‘å† å‹</div>
                        <div style="font-size: 0.85em; color: var(--warning); margin-top: 8px; font-weight: bold;">âš ï¸ è·¯è¾¹æœºå™¨äºº</div>
                    </div>
                    <div class="robot-type-card" data-type="custom" onclick="selectRobotType('custom')">
                        <div class="robot-type-name">è‡ªå®šä¹‰</div>
                    </div>
                </div>
                
                <!-- Wing Configuration -->
                <div style="margin-top: 25px; padding: 20px; background: var(--bg-light); border-radius: 12px;">
                    <h3 style="color: var(--text-dark); margin-bottom: 15px;">æœºç¿¼é…ç½® Wing Configuration</h3>
                    <div style="display: flex; gap: 20px; align-items: center;">
                        <label style="display: flex; align-items: center; cursor: pointer; font-size: 1.1em;">
                            <input type="checkbox" id="hasWing" style="width: 20px; height: 20px; margin-right: 10px; cursor: pointer;">
                            <span>æœºå™¨äººé…å¤‡æœºç¿¼ (Has Wing)</span>
                        </label>
                        <div id="wingInfo" style="display: none; color: var(--success); font-weight: 600;">
                            âœ“ å·²å¯ç”¨æœºç¿¼æ¨çƒåŠŸèƒ½
                        </div>
                    </div>
                </div>
            </div>

            <!-- 5. Driver Habits -->
            <div class="section" id="driverSection" style="display: none;">
                <div class="section-title">
                    ğŸ‘¤ é©¾é©¶å‘˜ä¹ æƒ¯
                </div>
                
                <!-- ä¹ æƒ¯æ ‡ç­¾ -->
                <div style="margin-bottom: 15px;">
                    <div style="display: flex; gap: 10px; margin-bottom: 10px; align-items: center;">
                        <label style="font-weight: 600; color: var(--text-dark);">ä¹ æƒ¯æ ‡ç­¾:</label>
                        <input type="text" id="customTagInput" placeholder="è¾“å…¥è‡ªå®šä¹‰æ ‡ç­¾" 
                            style="flex: 1; padding: 5px 10px; border: 1px solid var(--border); border-radius: 4px;"
                            onkeypress="if(event.key === 'Enter') addCustomTag()">
                        <button onclick="addCustomTag()" style="padding: 5px 15px; background: var(--primary); color: white; border: none; border-radius: 4px; cursor: pointer;">
                            æ·»åŠ 
                        </button>
                    </div>
                    <div id="driverTags" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- æ ‡ç­¾å°†åŠ¨æ€æ·»åŠ åˆ°è¿™é‡Œ -->
                    </div>
                </div>
                
                <textarea class="driver-notes" id="driverNotes" placeholder="åœ¨è¿™é‡Œè®°å½•é©¾é©¶å‘˜çš„å…¶ä»–ä¹ æƒ¯ã€åå¥½ç­–ç•¥ã€ç‰¹æ®ŠæŠ€å·§ç­‰...

ä¾‹å¦‚:
- å–œæ¬¢ä½¿ç”¨æœºæ¢°è‡‚æŠ“å–
- æ“…é•¿ç²¾å‡†å®šä½
- åå¥½å·¦ä¾§åœºåœ°"></textarea>
            </div>

            <!-- 6. AI Export -->
            <div class="section ai-export-section">
                <div class="section-title">
                    ğŸ¤– AI å¯¹æ‰‹ä¾¦å¯Ÿåˆ†æ
                </div>
                <div style="margin-bottom: 15px; color: var(--text-dark);">
                    <p>ğŸ“‹ å°†å¯¹æ‰‹çš„ Auton è·¯å¾„å›¾ã€æ¯”èµ›æ•°æ®ã€æœºå™¨äººç±»å‹å’Œé©¾é©¶å‘˜ä¹ æƒ¯å‘é€ç»™ GPT-4o å¤šæ¨¡æ€æ¨¡å‹ï¼Œç”Ÿæˆé’ˆå¯¹æ€§çš„ä¾¦å¯ŸæŠ¥å‘Šå’Œååˆ¶ç­–ç•¥ã€‚</p>
                    <p style="font-size: 0.9em; color: #666;">ğŸ’¡ æŠ¥å‘Šå°†ä»"å¦‚ä½•é’ˆå¯¹è¯¥å¯¹æ‰‹"çš„è§’åº¦ï¼Œåˆ†æå…¶ä¼˜åŠ¿ã€å¼±ç‚¹å¹¶æä¾›å…·ä½“çš„åº”å¯¹æ–¹æ¡ˆã€‚</p>
                </div>
                
                <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="btn btn-primary" onclick="previewAIData()">
                        <span>ğŸ‘ï¸ é¢„è§ˆæ•°æ®</span>
                    </button>
                    <button class="btn btn-success" onclick="exportToAI()">
                        <span>ğŸš€ ç”Ÿæˆå¯¹æ‰‹åˆ†ææŠ¥å‘Š</span>
                    </button>
                    <button class="btn btn-primary" onclick="downloadAllAutons()">
                        <span>ğŸ’¾ ä¸‹è½½æ‰€æœ‰ Auton å›¾ç‰‡</span>
                    </button>
                    <button class="btn btn-danger" onclick="confirmClearSavedData()" title="æ¸…é™¤æ‰€æœ‰è‡ªåŠ¨ä¿å­˜çš„æ•°æ®">
                        <span>ğŸ—‘ï¸ æ¸…é™¤ä¿å­˜æ•°æ®</span>
                    </button>
                </div>

                <div class="ai-preview" id="aiPreview" style="display: none;">
                    <h4>ğŸ“Š AI åˆ†æé¢„è§ˆæ•°æ®:</h4>
                    <pre id="aiPreviewContent"></pre>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'http://localhost:8000/api';
        
        // Global State
        let currentTeamData = null;
        let currentTeamId = null;
        let autons = [
            { id: 1, name: 'Auton 1', points: [] }
        ];
        let currentAutonIndex = 0;
        let currentState = 'wingpushing';
        let selectedRobotType = null;
        let hasWing = false;
        let isDrawing = false;
        
        // Driver habit tags
        let driverTags = [];
        const defaultTags = ['è¿›æ”»', 'é˜²å®ˆ', 'æœ€å20ç§’è¿›æ”»', 'double park'];
        
        // Auto-save settings
        const AUTOSAVE_KEY_PREFIX = 'rscoutx_team_';
        let autoSaveTimer = null;
        
        // Get team-specific storage key
        function getTeamStorageKey(teamId) {
            return `${AUTOSAVE_KEY_PREFIX}${teamId}`;
        }
        
        // Canvas
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        let baseMapImage = null;
        
        // State Colors
        const stateColors = {
            'idle': '#808080',
            'moving': '#1E90FF',
            'intaking': '#00FF00',
            'wingpushing': '#FF4500',
            'releasing': '#FFD700'
        };
        
        // Initialize
        async function init() {
            // Don't auto-load team data on init - user must search first
            // loadAutoSaveData(); // Removed - data will load when team is searched
            await loadBaseMap();
            setupCanvasEvents();
            updateAutonCounter();
            initializeDriverTags();
            
            // Optional: Show hint if there was a previous team
            const lastTeamKey = 'rscoutx_last_team_id';
            const lastTeamId = localStorage.getItem(lastTeamKey);
            if (lastTeamId) {
                console.log(`â„¹ï¸ ä¸Šæ¬¡ä½¿ç”¨çš„é˜Ÿä¼: ${lastTeamId}`);
            }
        }
        
        // Auto-save functions
        function saveData() {
            // Only save if we have a current team
            if (!currentTeamId) {
                console.log('âš ï¸ No team loaded, skipping save');
                return;
            }
            
            const dataToSave = {
                teamId: currentTeamId,
                autons: autons,
                currentAutonIndex: currentAutonIndex,
                selectedRobotType: selectedRobotType,
                hasWing: hasWing,
                driverNotes: document.getElementById('driverNotes').value,
                driverTags: driverTags,
                timestamp: new Date().toISOString()
            };
            
            try {
                const storageKey = getTeamStorageKey(currentTeamId);
                localStorage.setItem(storageKey, JSON.stringify(dataToSave));
                console.log(`âœ“ Data auto-saved for Team ${currentTeamId} at`, new Date().toLocaleTimeString());
            } catch (e) {
                console.error('Failed to save data:', e);
            }
        }
        
        function loadAutoSaveData() {
            // This is for initial page load - load last used team if any
            // When switching teams, use loadTeamData() instead
            try {
                // Try to load the last team from a separate key
                const lastTeamKey = 'rscoutx_last_team_id';
                const lastTeamId = localStorage.getItem(lastTeamKey);
                
                if (lastTeamId) {
                    const storageKey = getTeamStorageKey(lastTeamId);
                    const saved = localStorage.getItem(storageKey);
                    
                    if (saved) {
                        const data = JSON.parse(saved);
                        loadTeamDataFromStorage(data);
                        console.log('âœ“ Loaded auto-saved data for Team', lastTeamId, 'from', new Date(data.timestamp).toLocaleString());
                        showMessage(`å·²æ¢å¤é˜Ÿä¼ ${lastTeamId} çš„æ•°æ®`, 'info');
                    }
                }
            } catch (e) {
                console.error('Failed to load saved data:', e);
            }
        }
        
        function loadTeamData(teamId) {
            // Load data for a specific team
            try {
                const storageKey = getTeamStorageKey(teamId);
                const saved = localStorage.getItem(storageKey);
                
                if (saved) {
                    const data = JSON.parse(saved);
                    loadTeamDataFromStorage(data);
                    console.log(`âœ“ Loaded saved data for Team ${teamId}`);
                    showMessage(`å·²åŠ è½½é˜Ÿä¼ ${teamId} çš„ä¿å­˜æ•°æ®`, 'success');
                } else {
                    // No saved data for this team, reset to defaults
                    resetToDefaults();
                    console.log(`â„¹ï¸ No saved data for Team ${teamId}, using defaults`);
                }
                
                // Remember this as the last used team
                localStorage.setItem('rscoutx_last_team_id', teamId);
            } catch (e) {
                console.error('Failed to load team data:', e);
                resetToDefaults();
            }
        }
        
        function loadTeamDataFromStorage(data) {
            // Restore autons
            if (data.autons && data.autons.length > 0) {
                autons = data.autons;
            } else {
                autons = [{ id: 1, name: 'Auton 1', points: [] }];
            }
            
            // Restore current auton index
            if (data.currentAutonIndex !== undefined && data.currentAutonIndex < autons.length) {
                currentAutonIndex = data.currentAutonIndex;
            } else {
                currentAutonIndex = 0;
            }
            
            // Restore robot type
            if (data.selectedRobotType) {
                selectedRobotType = data.selectedRobotType;
                setTimeout(() => {
                    document.querySelectorAll('.robot-type-card').forEach(card => card.classList.remove('selected'));
                    const card = document.querySelector(`[data-type="${selectedRobotType}"]`);
                    if (card) card.classList.add('selected');
                }, 50);
            } else {
                selectedRobotType = null;
                setTimeout(() => {
                    document.querySelectorAll('.robot-type-card').forEach(card => card.classList.remove('selected'));
                }, 50);
            }
            
            // Restore wing setting
            if (data.hasWing !== undefined) {
                hasWing = data.hasWing;
            } else {
                hasWing = false;
            }
            setTimeout(() => {
                document.getElementById('hasWing').checked = hasWing;
                document.getElementById('wingInfo').style.display = hasWing ? 'block' : 'none';
            }, 50);
            
            // Restore driver notes
            if (data.driverNotes) {
                setTimeout(() => {
                    document.getElementById('driverNotes').value = data.driverNotes;
                }, 50);
            } else {
                setTimeout(() => {
                    document.getElementById('driverNotes').value = '';
                }, 50);
            }
            
            // Restore driver tags
            if (data.driverTags && data.driverTags.length > 0) {
                driverTags = data.driverTags;
            } else {
                driverTags = [];
            }
            setTimeout(() => {
                renderDriverTags();
            }, 50);
            
            // Update UI
            updateAutonInfo();
            redrawCanvas();
        }
        
        function resetToDefaults() {
            // Reset to default state when no saved data exists
            autons = [{ id: 1, name: 'Auton 1', points: [] }];
            currentAutonIndex = 0;
            selectedRobotType = null;
            hasWing = false;
            driverTags = [];
            
            setTimeout(() => {
                document.querySelectorAll('.robot-type-card').forEach(card => card.classList.remove('selected'));
                document.getElementById('hasWing').checked = false;
                document.getElementById('wingInfo').style.display = 'none';
                document.getElementById('driverNotes').value = '';
                renderDriverTags();
            }, 50);
            
            updateAutonInfo();
            redrawCanvas();
        }
        
        function triggerAutoSave() {
            // Debounce: wait 1 second after last change before saving
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
            }
            autoSaveTimer = setTimeout(() => {
                saveData();
            }, 1000);
        }
        
        function clearSavedData() {
            if (!currentTeamId) {
                showMessage('è¯·å…ˆæœç´¢é˜Ÿä¼', 'error');
                return;
            }
            
            try {
                const storageKey = getTeamStorageKey(currentTeamId);
                localStorage.removeItem(storageKey);
                console.log(`âœ“ Saved data cleared for Team ${currentTeamId}`);
                showMessage(`å·²æ¸…é™¤é˜Ÿä¼ ${currentTeamId} çš„ä¿å­˜æ•°æ®`, 'info');
            } catch (e) {
                console.error('Failed to clear saved data:', e);
            }
        }
        
        function confirmClearSavedData() {
            if (!currentTeamId) {
                showMessage('è¯·å…ˆæœç´¢é˜Ÿä¼', 'error');
                return;
            }
            
            const teamNumber = currentTeamData?.team?.team_number || currentTeamId;
            
            if (confirm(`âš ï¸ ç¡®å®šè¦æ¸…é™¤é˜Ÿä¼ ${teamNumber} çš„æ‰€æœ‰ä¿å­˜æ•°æ®å—ï¼Ÿ\n\nè¿™å°†åˆ é™¤:\nâ€¢ æ‰€æœ‰ Auton è·¯å¾„\nâ€¢ æœºå™¨äººé…ç½®\nâ€¢ é©¾é©¶å‘˜ä¹ æƒ¯ç¬”è®°\n\næ­¤æ“ä½œæ— æ³•æ’¤é”€!`)) {
                clearSavedData();
                // Reset to default state
                resetToDefaults();
                showMessage('æ•°æ®å·²æ¸…é™¤ï¼Œå·²é‡ç½®ä¸ºé»˜è®¤çŠ¶æ€', 'info');
            }
        }
        
        async function loadBaseMap() {
            // Try multiple possible paths for the map image
            const possiblePaths = [
                './pushback_map.png',           // Same directory as HTML
                '../pushback_map.png',          // Parent directory
                '/pushback_map.png',            // Root of server
                'pushback_map.png'              // Current directory
            ];
            
            let loaded = false;
            
            for (const path of possiblePaths) {
                try {
                    await new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => {
                            baseMapImage = img;
                            redrawCanvas();
                            console.log(`âœ“ Map loaded from: ${path}`);
                            loaded = true;
                            resolve();
                        };
                        img.onerror = () => {
                            console.log(`âœ— Failed to load from: ${path}`);
                            reject();
                        };
                        img.src = path;
                    });
                    
                    if (loaded) break;
                } catch (e) {
                    // Try next path
                    continue;
                }
            }
            
            if (!loaded) {
                console.warn('Could not load pushback_map.png from any path, using default grid');
                drawDefaultGrid();
            }
        }
        
        function drawDefaultGrid() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 800, 800);
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 800; i += 50) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, 800);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(800, i);
                ctx.stroke();
            }
            
            // Draw field outline
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.strokeRect(50, 50, 700, 700);
            
            // Draw center cross
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(400, 50);
            ctx.lineTo(400, 750);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(50, 400);
            ctx.lineTo(750, 400);
            ctx.stroke();
            
            // Add text
            ctx.fillStyle = '#fff';
            ctx.font = '28px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('VEX Pushback Field', 400, 380);
            ctx.font = '16px Arial';
            ctx.fillStyle = '#aaa';
            ctx.fillText('pushback_map.png æœªæ‰¾åˆ° - ä½¿ç”¨é»˜è®¤ç½‘æ ¼', 400, 410);
            ctx.font = '14px Arial';
            ctx.fillText('ç‚¹å‡»åœ°å›¾æ·»åŠ è·¯å¾„ç‚¹', 400, 440);
        }
        
        function setupCanvasEvents() {
            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                handleCanvasClick(e);
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (isDrawing) {
                    handleCanvasClick(e);
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                isDrawing = false;
            });
            
            canvas.addEventListener('mouseleave', () => {
                isDrawing = false;
            });
        }
        
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round((e.clientX - rect.left) * (canvas.width / rect.width));
            const y = Math.round((e.clientY - rect.top) * (canvas.height / rect.height));
            
            const point = {
                x,
                y,
                robot_state: { state: currentState }
            };
            
            autons[currentAutonIndex].points.push(point);
            redrawCanvas();
            updatePointsList();
            triggerAutoSave(); // Auto-save after adding point
        }
        
        function redrawCanvas() {
            // Clear
            ctx.clearRect(0, 0, 800, 800);
            
            // Draw base map or grid
            if (baseMapImage) {
                ctx.drawImage(baseMapImage, 0, 0, 800, 800);
            } else {
                drawDefaultGrid();
            }
            
            const points = autons[currentAutonIndex].points;
            if (points.length === 0) return;
            
            // Draw path lines
            if (points.length > 1) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 1; i < points.length; i++) {
                    ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
            
            // Draw points
            points.forEach((point, index) => {
                const color = stateColors[point.robot_state.state] || '#FFFFFF';
                
                // Draw point circle
                ctx.fillStyle = color;
                ctx.strokeStyle = '#FFFFFF';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(point.x, point.y, 12, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
                
                // Draw number
                ctx.fillStyle = '#000';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, point.x, point.y);
            });
        }
        
        function updatePointsList() {
            const list = document.getElementById('pointsList');
            const points = autons[currentAutonIndex].points;
            
            const stateEmojis = {
                'idle': 'â­•',
                'moving': 'ğŸ”µ',
                'intaking': 'ğŸŸ¢',
                'wingpushing': 'ğŸŸ ',
                'releasing': 'ğŸŸ¡'
            };
            
            list.innerHTML = points.map((p, i) => {
                const emoji = stateEmojis[p.robot_state.state];
                return `
                    <div class="point-item">
                        <span><strong>#${i+1}</strong> (${p.x}, ${p.y}) ${emoji} ${p.robot_state.state}</span>
                        <button class="delete-btn" onclick="removePoint(${i})">Ã—</button>
                    </div>
                `;
            }).join('');
        }
        
        function removePoint(index) {
            autons[currentAutonIndex].points.splice(index, 1);
            redrawCanvas();
            updatePointsList();
            triggerAutoSave(); // Auto-save
            showMessage('è·¯å¾„ç‚¹å·²åˆ é™¤', 'info');
        }
        
        function selectState(state) {
            currentState = state;
            document.querySelectorAll('.state-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-state="${state}"]`).classList.add('active');
            triggerAutoSave(); // Auto-save
        }
        
        function selectRobotType(type) {
            selectedRobotType = type;
            document.querySelectorAll('.robot-type-card').forEach(card => {
                card.classList.remove('selected');
            });
            document.querySelector(`[data-type="${type}"]`).classList.add('selected');
            triggerAutoSave(); // Auto-save
            showMessage(`å·²é€‰æ‹©æœºå™¨äººç±»å‹: ${type}`, 'success');
        }
        
        // Auton Navigation
        function updateAutonCounter() {
            document.getElementById('currentAutonIndex').textContent = currentAutonIndex + 1;
            document.getElementById('totalAutons').textContent = autons.length;
        }
        
        function updateAutonInfo() {
            // Update auton counter display
            updateAutonCounter();
            // Update points list display
            updatePointsList();
        }
        
        function prevAuton() {
            if (currentAutonIndex > 0) {
                currentAutonIndex--;
                redrawCanvas();
                updatePointsList();
                updateAutonCounter();
                triggerAutoSave(); // Auto-save
            }
        }
        
        function nextAuton() {
            if (currentAutonIndex < autons.length - 1) {
                currentAutonIndex++;
                redrawCanvas();
                updatePointsList();
                updateAutonCounter();
                triggerAutoSave(); // Auto-save
            }
        }
        
        function addAuton() {
            autons.push({
                id: autons.length + 1,
                name: `Auton ${autons.length + 1}`,
                points: []
            });
            currentAutonIndex = autons.length - 1;
            redrawCanvas();
            updatePointsList();
            updateAutonCounter();
            triggerAutoSave(); // Auto-save
            showMessage('æ–°å¢ Auton æˆåŠŸ', 'success');
        }
        
        function deleteAuton() {
            if (autons.length === 1) {
                showMessage('è‡³å°‘ä¿ç•™ä¸€ä¸ª Auton', 'warning');
                return;
            }
            
            autons.splice(currentAutonIndex, 1);
            if (currentAutonIndex >= autons.length) {
                currentAutonIndex = autons.length - 1;
            }
            redrawCanvas();
            updatePointsList();
            updateAutonCounter();
            triggerAutoSave(); // Auto-save
            showMessage('Auton å·²åˆ é™¤', 'info');
        }
        
        function clearCurrentPath() {
            autons[currentAutonIndex].points = [];
            redrawCanvas();
            updatePointsList();
            triggerAutoSave(); // Auto-save
            showMessage('è·¯å¾„å·²æ¸…ç©º', 'info');
        }
        
        // Team Search
        async function searchTeam() {
            const teamNumber = document.getElementById('teamNumber').value.trim();
            
            if (!teamNumber) {
                showMessage('è¯·è¾“å…¥é˜Ÿä¼ç¼–å·', 'error');
                return;
            }
            
            try {
                showMessage('æ­£åœ¨åŠ è½½é˜Ÿä¼å†å²æ•°æ®...', 'info');
                
                // Get team
                const teamsResult = await fetch(`${API_BASE}/teams/`);
                const teams = await teamsResult.json();
                let team = teams.find(t => t.team_number === teamNumber);
                
                if (!team) {
                    showMessage('æœªæ‰¾åˆ°é˜Ÿä¼ä¿¡æ¯ï¼Œæ­£åœ¨åˆ›å»ºå¹¶çˆ¬å–æ•°æ®...', 'info');
                    // Create team if not exists
                    const createResult = await fetch(`${API_BASE}/teams/`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            team_number: teamNumber,
                            team_name: `Team ${teamNumber}`,
                            organization: 'æœªçŸ¥',
                            region: 'æœªçŸ¥'
                        })
                    });
                    team = await createResult.json();
                }
                
                currentTeamId = team.id;
                
                // Try to sync/scrape new match data from RobotEvents
                try {
                    showMessage('æ­£åœ¨ä» RobotEvents çˆ¬å– 2025-2026 èµ›å­£æ•°æ®...', 'info');
                    const syncResult = await fetch(`${API_BASE}/matches/sync?team=${teamNumber}&event=ALL&scraper=robotevents`, {
                        method: 'GET'
                    });
                    const syncData = await syncResult.json();
                    console.log('Sync result:', syncData);
                    
                    if (syncData.success) {
                        if (syncData.new_matches > 0) {
                            showMessage(`âœ“ æˆåŠŸçˆ¬å– ${syncData.new_matches} åœºæ–°æ¯”èµ›ï¼Œå…± ${syncData.total_matches} åœº`, 'success');
                        } else {
                            showMessage(`âœ“ æ•°æ®å·²æ˜¯æœ€æ–° (å…± ${syncData.total_matches} åœºæ¯”èµ›)`, 'success');
                        }
                        
                        if (syncData.mock_data) {
                            showMessage('âš ï¸ ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®ï¼ˆæœªé…ç½®çœŸå® API Keyï¼‰', 'warning');
                        }
                    }
                } catch (syncError) {
                    console.warn('åŒæ­¥æ¯”èµ›æ•°æ®å¤±è´¥:', syncError);
                    showMessage('âš ï¸ æ— æ³•åŒæ­¥æœ€æ–°æ•°æ®ï¼Œæ˜¾ç¤ºç°æœ‰è®°å½•', 'warning');
                }
                
                // é‡è¦ï¼šåœ¨åŒæ­¥åé‡æ–°è·å–æœ€æ–°çš„ç»Ÿè®¡æ•°æ®å’Œæ¯”èµ›è®°å½•
                showMessage('æ­£åœ¨åŠ è½½æœ€æ–°æ•°æ®...', 'info');
                
                // Get updated stats (after sync)
                const statsResult = await fetch(`${API_BASE}/matches/stats/${team.id}`);
                const stats = await statsResult.json();
                
                // Get updated matches for this team (after sync)
                const matchesResult = await fetch(`${API_BASE}/matches/`);
                const allMatches = await matchesResult.json();
                const teamMatches = allMatches.filter(m => m.team_id === team.id);
                
                console.log(`ğŸ“Š åŠ è½½å®Œæˆ: ${teamMatches.length} åœºæ¯”èµ›, èƒœç‡ ${(stats.win_rate * 100).toFixed(1)}%`);
                
                // Display updated data
                displayTeamInfo(team, stats, teamMatches);
                
                currentTeamData = { team, stats, matches: teamMatches };
                currentTeamId = team.id;
                
                // Load saved data for this team (Autons, robot config, notes)
                loadTeamData(team.id);
                
                // Show sections
                document.getElementById('teamInfoSection').style.display = 'block';
                document.getElementById('autonSection').style.display = 'block';
                document.getElementById('robotSection').style.display = 'block';
                document.getElementById('driverSection').style.display = 'block';
                
                // æ˜¾ç¤ºè¯¦ç»†çš„åŠ è½½æˆåŠŸä¿¡æ¯
                const winRate = (stats.win_rate * 100).toFixed(1);
                const avgScore = stats.avg_score_for ? stats.avg_score_for.toFixed(1) : '0.0';
                showMessage(`âœ… æ•°æ®åŠ è½½æˆåŠŸ! ${teamMatches.length} åœºæ¯”èµ› | èƒœç‡ ${winRate}% | å¹³å‡åˆ† ${avgScore}`, 'success');
            } catch (error) {
                showMessage('åŠ è½½å¤±è´¥: ' + error.message, 'error');
                console.error(error);
            }
        }
        
        function displayTeamInfo(team, stats, matches) {
            // Basic info
            document.getElementById('displayTeamNumber').textContent = team.team_number;
            document.getElementById('displayTeamName').textContent = team.team_name || 'Unknown';
            document.getElementById('displayOrganization').textContent = team.organization || 'æœªçŸ¥';
            document.getElementById('displayRegion').textContent = team.region || 'æœªçŸ¥';
            
            // Stats
            document.getElementById('totalMatches').textContent = stats.total_matches || 0;
            document.getElementById('winRate').textContent = ((stats.win_rate || 0) * 100).toFixed(1) + '%';
            document.getElementById('avgScore').textContent = (stats.avg_score_for || 0).toFixed(1);
            document.getElementById('maxScore').textContent = stats.max_score_for || 0;
            document.getElementById('autonScore').textContent = Math.floor((stats.avg_score_for || 0) * 0.3);
            
            // Count unique events
            const uniqueEvents = [...new Set(matches.map(m => m.event_id))];
            document.getElementById('eventCount').textContent = uniqueEvents.length;
            
            // Display match history
            displayMatchHistory(matches);
        }
        
        function displayMatchHistory(matches) {
            const container = document.getElementById('matchHistory');
            
            if (matches.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-light); padding: 30px;">æš‚æ— æ¯”èµ›è®°å½•</div>';
                return;
            }
            
            // Sort by date (newest first)
            const sortedMatches = [...matches].sort((a, b) => {
                const dateA = a.match_date ? new Date(a.match_date) : new Date(0);
                const dateB = b.match_date ? new Date(b.match_date) : new Date(0);
                return dateB - dateA;
            });
            
            // Take latest 20 matches
            const recentMatches = sortedMatches.slice(0, 20);
            
            container.innerHTML = recentMatches.map(match => {
                const isWin = match.result === 'win';
                const resultColor = isWin ? 'var(--success)' : 'var(--danger)';
                const resultIcon = isWin ? 'âœ…' : 'âŒ';
                const allianceColor = match.alliance === 'red' ? '#ff4444' : '#4444ff';
                const date = match.match_date ? new Date(match.match_date).toLocaleDateString('zh-CN') : 'æœªçŸ¥';
                
                return `
                    <div style="background: white; padding: 15px; margin-bottom: 10px; border-radius: 10px; border-left: 4px solid ${resultColor}; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-weight: bold; font-size: 1.1em;">${match.match_id}</span>
                                <span style="color: var(--text-light); margin-left: 10px;">${date}</span>
                            </div>
                            <div style="font-size: 1.5em;">${resultIcon}</div>
                        </div>
                        <div style="margin-top: 10px;">
                            <span style="background: ${allianceColor}; color: white; padding: 3px 10px; border-radius: 5px; font-size: 0.9em;">
                                ${match.alliance === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}
                            </span>
                            <span style="margin-left: 15px; font-weight: bold; font-size: 1.2em;">
                                ${match.score_for} : ${match.score_against}
                            </span>
                            <span style="margin-left: 10px; color: ${resultColor}; font-weight: bold;">
                                ${isWin ? 'èƒœåˆ©' : 'å¤±è´¥'}
                            </span>
                        </div>
                        <div style="margin-top: 8px; color: var(--text-light); font-size: 0.9em;">
                            ğŸ“ ${match.event_name || match.event_id}
                        </div>
                        ${match.opponents ? `
                            <div style="margin-top: 5px; color: var(--text-light); font-size: 0.85em;">
                                ğŸ¤ å¯¹æ‰‹: ${match.opponents}
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }
        
        // AI Export
        function previewAIData() {
            const driverNotes = document.getElementById('driverNotes').value;
            
            const data = {
                team: currentTeamData,
                robotType: selectedRobotType,
                hasWing: hasWing,
                driverHabits: driverNotes,
                autons: autons.map(a => ({
                    name: a.name,
                    pointCount: a.points.length,
                    points: a.points
                }))
            };
            
            document.getElementById('aiPreviewContent').textContent = JSON.stringify(data, null, 2);
            document.getElementById('aiPreview').style.display = 'block';
            showMessage('æ•°æ®é¢„è§ˆå·²ç”Ÿæˆ', 'info');
        }
        
        // Driver Tag Management Functions
        function initializeDriverTags() {
            // Initialize with default tags if no tags exist
            if (driverTags.length === 0) {
                driverTags = [...defaultTags];
            }
            renderDriverTags();
        }
        
        function renderDriverTags() {
            const container = document.getElementById('driverTags');
            if (!container) return;
            
            container.innerHTML = '';
            
            // Add default tags first
            defaultTags.forEach(tag => {
                const tagElement = createTagElement(tag, true);
                container.appendChild(tagElement);
            });
            
            // Add custom tags
            const customTags = driverTags.filter(tag => !defaultTags.includes(tag));
            customTags.forEach(tag => {
                const tagElement = createTagElement(tag, false);
                container.appendChild(tagElement);
            });
        }
        
        function createTagElement(tagText, isDefault) {
            const tag = document.createElement('div');
            tag.className = 'driver-tag';
            
            const isActive = driverTags.includes(tagText);
            if (isActive) {
                tag.classList.add('active');
            }
            
            tag.innerHTML = `
                <span class="tag-text">${tagText}</span>
                ${!isDefault ? '<span class="tag-remove" onclick="removeTag(\'' + tagText.replace(/'/g, "\\'") + '\')">Ã—</span>' : ''}
            `;
            
            tag.onclick = (e) => {
                if (e.target.classList.contains('tag-remove')) {
                    return; // Let the remove handler deal with it
                }
                toggleTag(tagText);
            };
            
            return tag;
        }
        
        function toggleTag(tagText) {
            const index = driverTags.indexOf(tagText);
            if (index === -1) {
                // Add tag
                driverTags.push(tagText);
            } else {
                // Remove tag
                driverTags.splice(index, 1);
            }
            renderDriverTags();
            triggerAutoSave();
        }
        
        function addCustomTag() {
            const input = document.getElementById('customTagInput');
            const tagText = input.value.trim();
            
            if (!tagText) {
                showMessage('è¯·è¾“å…¥æ ‡ç­¾å†…å®¹', 'error');
                return;
            }
            
            if (driverTags.includes(tagText) || defaultTags.includes(tagText)) {
                showMessage('è¯¥æ ‡ç­¾å·²å­˜åœ¨', 'error');
                return;
            }
            
            driverTags.push(tagText);
            input.value = '';
            renderDriverTags();
            triggerAutoSave();
            showMessage('æ ‡ç­¾å·²æ·»åŠ ', 'success');
        }
        
        function removeTag(tagText) {
            const index = driverTags.indexOf(tagText);
            if (index !== -1) {
                driverTags.splice(index, 1);
                renderDriverTags();
                triggerAutoSave();
                showMessage('æ ‡ç­¾å·²åˆ é™¤', 'success');
            }
        }
        
        async function exportToAI() {
            if (!currentTeamData) {
                showMessage('è¯·å…ˆæœç´¢é˜Ÿä¼', 'error');
                return;
            }
            
            try {
                showMessage('æ­£åœ¨ç”Ÿæˆ AI åˆ†ææŠ¥å‘Š...', 'info');
                
                // Render all autons
                const autonImages = [];
                for (let i = 0; i < autons.length; i++) {
                    const auton = autons[i];
                    if (auton.points.length < 2) continue;
                    
                    const response = await fetch(`${API_BASE}/path/render/image`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            method: 'polyline',  // æ”¹ä¸ºç›´çº¿è¿æ¥ï¼Œä¸ç”»å¸ƒä¸€è‡´
                            points: auton.points,
                            coordinate_system: 'pixel',
                            style: {
                                color: '#FF0000',
                                width: 3,
                                opacity: 0.8,
                                arrow: true,
                                show_state_labels: true,
                                state_icon_size: 20
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        autonImages.push({
                            name: auton.name,
                            blob: blob
                        });
                    }
                }
                
                // Create AI report
                const driverNotes = document.getElementById('driverNotes').value;
                const reportData = {
                    team_id: currentTeamId,
                    event_id: null, // Get all history
                    include_map: true,
                    include_driver: true,
                    include_robot: true,
                    language: 'zh',
                    custom_context: `
æœºå™¨äººç±»å‹: ${selectedRobotType || 'æœªé€‰æ‹©'}${selectedRobotType === 'ruiguan' ? ' (è·¯è¾¹æœºå™¨äºº)' : ''}
æ˜¯å¦æœ‰æœºç¿¼: ${hasWing ? 'æ˜¯ âœ“' : 'å¦'}
é©¾é©¶å‘˜ä¹ æƒ¯æ ‡ç­¾: ${driverTags.length > 0 ? driverTags.join(', ') : 'æ— '}
é©¾é©¶å‘˜å…¶ä»–ä¹ æƒ¯: ${driverNotes || 'æ— '}
Auton æ•°é‡: ${autons.length}
æ€»è·¯å¾„ç‚¹æ•°: ${autons.reduce((sum, a) => sum + a.points.length, 0)}
å†å²æ¯”èµ›æ•°: ${currentTeamData.matches ? currentTeamData.matches.length : 0}
å‚èµ›æ¬¡æ•°: ${currentTeamData.matches ? [...new Set(currentTeamData.matches.map(m => m.event_id))].length : 0}
                    `
                };
                
                let reportMarkdown = '';
                let aiSuccess = false;
                
                // Try to get AI report
                try {
                    console.log('Sending report request:', reportData);
                    
                    const reportResponse = await fetch(`${API_BASE}/report/generate`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(reportData)
                    });
                    
                    console.log('Report API status:', reportResponse.status);
                    
                    if (!reportResponse.ok) {
                        const errorText = await reportResponse.text();
                        console.error('Report API error:', reportResponse.status, errorText);
                        throw new Error(`API returned ${reportResponse.status}: ${errorText}`);
                    }
                    
                    const reportResult = await reportResponse.json();
                    
                    console.log('Report API response:', reportResult);
                    
                    if (reportResult.success && reportResult.report_markdown) {
                        reportMarkdown = reportResult.report_markdown;
                        aiSuccess = true;
                        console.log('AI report generated successfully');
                    } else if (reportResult.message) {
                        console.error('Report generation failed:', reportResult.message);
                    } else {
                        console.error('Report generation returned success=false with no message');
                    }
                } catch (aiError) {
                    console.error('AI generation failed with exception:', aiError);
                }
                
                // Generate fallback report if AI failed
                if (!aiSuccess) {
                    const team = currentTeamData.team;
                    const matches = currentTeamData.matches || [];
                    const totalMatches = matches.length;
                    const events = [...new Set(matches.map(m => m.event_id))].length;
                    const avgScore = totalMatches > 0 ? (matches.reduce((sum, m) => sum + (m.score || 0), 0) / totalMatches).toFixed(1) : 0;
                    const maxScore = totalMatches > 0 ? Math.max(...matches.map(m => m.score || 0)) : 0;
                    
                    reportMarkdown = `# ğŸ¤– é˜Ÿä¼åˆ†ææŠ¥å‘Š - ${team.team_number}

## âš ï¸ æç¤º
AI æ™ºèƒ½åˆ†ææš‚æ—¶ä¸å¯ç”¨ï¼ˆå¯èƒ½æ˜¯ API é…ç½®é—®é¢˜ï¼‰ï¼Œä»¥ä¸‹æ˜¯åŸºäºæ•°æ®çš„è‡ªåŠ¨ç”ŸæˆæŠ¥å‘Šã€‚

## ğŸ“Š åŸºæœ¬ä¿¡æ¯
- **é˜Ÿä¼ç¼–å·**: ${team.team_number}
- **é˜Ÿä¼åç§°**: ${team.team_name}
- **ç»„ç»‡**: ${team.organization || 'æœªçŸ¥'}
- **ä½ç½®**: ${team.city || 'æœªçŸ¥'}, ${team.region || 'æœªçŸ¥'}, ${team.country || 'æœªçŸ¥'}

## ğŸ† æ¯”èµ›ç»Ÿè®¡
- **å‚èµ›æ¬¡æ•°**: ${events} åœºèµ›äº‹
- **æ€»æ¯”èµ›æ•°**: ${totalMatches} åœº
- **å¹³å‡å¾—åˆ†**: ${avgScore} åˆ†
- **æœ€é«˜å¾—åˆ†**: ${maxScore} åˆ†
- **æ’å**: ${team.ranking || 'N/A'}

## ğŸ¤– æœºå™¨äººé…ç½®
- **ç±»å‹**: ${selectedRobotType || 'æœªé€‰æ‹©'}${selectedRobotType === 'ruiguan' ? ' âš ï¸ (è·¯è¾¹æœºå™¨äºº)' : ''}
- **æœºç¿¼**: ${hasWing ? 'æœ‰ âœ“' : 'æ— '}

## ğŸ¯ Auton è·¯å¾„
- **æ€» Auton æ•°**: ${autons.length}
- **æ€»è·¯å¾„ç‚¹æ•°**: ${autons.reduce((sum, a) => sum + a.points.length, 0)}

${autons.map((a, i) => `### Auton ${i + 1}: ${a.name}
- è·¯å¾„ç‚¹: ${a.points.length} ä¸ª
- æœºå™¨äººçŠ¶æ€: ${a.points.map(p => p.state).join(' â†’ ')}`).join('\n\n')}

## ğŸ® é©¾é©¶å‘˜ä¹ æƒ¯
${driverNotes || 'æ— å¤‡æ³¨'}

## ğŸ’¡ å»ºè®®
${totalMatches > 0 ? `
- é˜Ÿä¼è¡¨ç°${avgScore > 50 ? 'ä¼˜ç§€' : avgScore > 30 ? 'è‰¯å¥½' : 'éœ€è¦æ”¹è¿›'}
- å»ºè®®å¤šç»ƒä¹  Auton è·¯å¾„çš„ç²¾ç¡®åº¦
- ${hasWing ? 'å……åˆ†åˆ©ç”¨æœºç¿¼ä¼˜åŠ¿' : 'è€ƒè™‘æ·»åŠ æœºç¿¼é…ç½®'}
` : 'æš‚æ— è¶³å¤Ÿæ•°æ®è¿›è¡Œåˆ†æ'}

---
*æŠ¥å‘Šç”Ÿæˆæ—¶é—´: ${new Date().toLocaleString('zh-CN')}*
*ç”Ÿæˆæ–¹å¼: è‡ªåŠ¨ç”Ÿæˆï¼ˆAI ä¸å¯ç”¨ï¼‰*

**é…ç½® AI åˆ†æçš„æ­¥éª¤ï¼š**
1. ç¡®ä¿åç«¯ .env æ–‡ä»¶ä¸­é…ç½®äº†æœ‰æ•ˆçš„ OPENAI_API_KEY
2. å°† OPENAI_MODEL æ”¹ä¸º gpt-4 æˆ– gpt-4-turbo
3. é‡å¯åç«¯æœåŠ¡`;
                }
                
                // Open report in new window
                const win = window.open('', '_blank');
                win.document.write(`
                    <html>
                    <head>
                        <title>${aiSuccess ? 'AI ' : ''}é’ˆå¯¹æ€§åˆ†ææŠ¥å‘Š - å¯¹æ‰‹ ${currentTeamData.team.team_number}</title>
                        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
                        <style>
                            body { font-family: 'Segoe UI', Arial, sans-serif; padding: 40px; max-width: 1200px; margin: 0 auto; background: #f5f5f5; line-height: 1.6; }
                            h1 { color: #667eea; border-bottom: 3px solid #667eea; padding-bottom: 10px; }
                            h2 { color: #764ba2; margin-top: 30px; }
                            h3 { color: #457b9d; margin-top: 20px; }
                            h4 { color: #495057; margin-top: 15px; }
                            .report { background: white; padding: 30px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
                            .warning { background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin: 20px 0; border-radius: 5px; }
                            .markdown-body { font-size: 16px; }
                            .markdown-body p { margin: 10px 0; }
                            .markdown-body ul, .markdown-body ol { margin-left: 20px; padding-left: 20px; }
                            .markdown-body li { margin: 5px 0; }
                            .markdown-body strong { font-weight: 600; color: #2c3e50; }
                            .markdown-body em { font-style: italic; color: #555; }
                            .markdown-body blockquote { border-left: 4px solid #667eea; padding-left: 15px; margin: 15px 0; color: #555; }
                            .markdown-body table { border-collapse: collapse; width: 100%; margin: 15px 0; }
                            .markdown-body th, .markdown-body td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
                            .markdown-body th { background: #f8f9fa; font-weight: 600; }
                            .markdown-body code { background: #f4f4f4; padding: 2px 6px; border-radius: 3px; font-family: 'Consolas', monospace; color: #e83e8c; }
                            .markdown-body pre { background: #f8f9fa; padding: 15px; border-radius: 5px; overflow-x: auto; }
                            .markdown-body pre code { background: none; padding: 0; color: inherit; }
                            .images { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 30px; }
                            .images > div { display: flex; flex-direction: column; align-items: center; }
                            .images img { width: 100%; height: auto; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.2); display: block; vertical-align: top; }
                            .images .img-caption { text-align: center; margin-top: 10px; font-weight: bold; color: #667eea; }
                        </style>
                    </head>
                    <body>
                        <div class="report">
                            ${aiSuccess ? '' : '<div class="warning">âš ï¸ AI æ™ºèƒ½åˆ†ææš‚æ—¶ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºè‡ªåŠ¨ç”ŸæˆæŠ¥å‘Š</div>'}
                            <div class="markdown-body" id="reportContent"></div>
                            ${autonImages.length > 0 ? '<h2>ğŸ¯ å¯¹æ‰‹ Auton è·¯å¾„åˆ†æ</h2>' : ''}
                            <div class="images" id="autonImages"></div>
                        </div>
                        <script>
                            // Render markdown
                            const markdownText = ${JSON.stringify(reportMarkdown)};
                            document.getElementById('reportContent').innerHTML = marked.parse(markdownText);
                        </script>
                    </body>
                    </html>
                `);
                
                // Add images
                autonImages.forEach(img => {
                    const div = win.document.createElement('div');
                    const imgElement = win.document.createElement('img');
                    imgElement.src = URL.createObjectURL(img.blob);
                    imgElement.alt = img.name;
                    imgElement.title = img.name;
                    const caption = win.document.createElement('div');
                    caption.className = 'img-caption';
                    caption.textContent = img.name;
                    div.appendChild(imgElement);
                    div.appendChild(caption);
                    win.document.getElementById('autonImages').appendChild(div);
                });
                
                showMessage(aiSuccess ? 'AI åˆ†ææŠ¥å‘Šå·²ç”Ÿæˆ!' : 'æŠ¥å‘Šå·²ç”Ÿæˆï¼ˆAI ä¸å¯ç”¨ï¼Œæ˜¾ç¤ºåŸºç¡€æŠ¥å‘Šï¼‰', aiSuccess ? 'success' : 'warning');
            } catch (error) {
                console.error('Export error:', error);
                showMessage('å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
            }
        }
        
        async function downloadAllAutons() {
            for (let i = 0; i < autons.length; i++) {
                const auton = autons[i];
                if (auton.points.length < 2) continue;
                
                try {
                    const response = await fetch(`${API_BASE}/path/render/image`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            method: 'spline',
                            points: auton.points,
                            coordinate_system: 'pixel',
                            style: {
                                color: '#FF0000',
                                width: 3,
                                opacity: 0.8,
                                arrow: true,
                                show_state_labels: true,
                                state_icon_size: 20
                            }
                        })
                    });
                    
                    if (response.ok) {
                        const blob = await response.blob();
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${auton.name}.png`;
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                } catch (error) {
                    console.error(`Failed to download ${auton.name}:`, error);
                }
            }
            
            showMessage(`ä¸‹è½½å®Œæˆ! å…± ${autons.length} å¼ å›¾ç‰‡`, 'success');
        }
        
        // Utility: Show Message
        function showMessage(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `message-toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.animation = 'slideIn 0.3s ease-out reverse';
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }
        
        // Wing checkbox handler
        document.getElementById('hasWing').addEventListener('change', function(e) {
            hasWing = e.target.checked;
            document.getElementById('wingInfo').style.display = hasWing ? 'block' : 'none';
            triggerAutoSave(); // Auto-save
            if (hasWing) {
                showMessage('æœºç¿¼åŠŸèƒ½å·²å¯ç”¨', 'success');
            } else {
                showMessage('æœºç¿¼åŠŸèƒ½å·²ç¦ç”¨', 'info');
            }
        });
        
        // Driver notes auto-save
        document.getElementById('driverNotes').addEventListener('input', function() {
            triggerAutoSave();
        });
        
        // Initialize on load
        init();
    </script>
</body>
</html>
